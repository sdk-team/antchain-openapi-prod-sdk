"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const $tea = __importStar(require("@alicloud/tea-typescript"));
const xml2js_1 = require("xml2js");
const kitx_1 = __importDefault(require("kitx"));
const mime_1 = require("mime");
const crypto_1 = require("crypto");
const crc_1 = __importDefault(require("./crc"));
const os_1 = require("os");
const signature_1 = require("./signature");
const DEFAULT_AGENT = `AlibabaCloud (${os_1.platform()}; ${os_1.arch()}) Node.js/${process.version} Core/1.0.1`;
function parseXML(body) {
    let parser = new xml2js_1.Parser({ explicitArray: false });
    let result = {};
    // parseString 实际上是一个同步方法
    parser.parseString(body, function (err, output) {
        result.err = err;
        result.output = output;
    });
    if (result.err) {
        throw result.err;
    }
    return result.output;
}
function base64Decode(value) {
    if (!value) {
        return '';
    }
    const strs = value.split('/');
    const result = Buffer.from(strs[strs.length - 1], 'base64').toString('utf8');
    strs[strs.length - 1] = result;
    return strs.join('/');
}
class RuntimeOptions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoretry: 'autoretry',
            ignoreSSL: 'ignoreSSL',
            maxAttempts: 'maxAttempts',
            backoffPolicy: 'backoffPolicy',
            backoffPeriod: 'backoffPeriod',
            readTimeout: 'readTimeout',
            connectTimeout: 'connectTimeout',
            localAddr: 'localAddr',
            httpProxy: 'httpProxy',
            httpsProxy: 'httpsProxy',
            noProxy: 'noProxy',
            maxIdleConns: 'maxIdleConns',
            socks5Proxy: 'socks5Proxy',
            socks5NetWork: 'socks5NetWork',
            uploadLimitSpeed: 'uploadLimitSpeed',
            listener: 'listener',
        };
    }
    static types() {
        return {
            autoretry: 'boolean',
            ignoreSSL: 'boolean',
            maxAttempts: 'number',
            backoffPolicy: 'string',
            backoffPeriod: 'number',
            readTimeout: 'number',
            connectTimeout: 'number',
            localAddr: 'string',
            httpProxy: 'string',
            httpsProxy: 'string',
            noProxy: 'string',
            maxIdleConns: 'number',
            socks5Proxy: 'string',
            socks5NetWork: 'string',
            uploadLimitSpeed: 'number',
            listener: 'any',
        };
    }
}
exports.RuntimeOptions = RuntimeOptions;
class Client {
    static getErrMessage(msg) {
        let body = parseXML(msg);
        return body.Error || {};
    }
    static toMeta(val, prefix) {
        let ret = {};
        if (!val) {
            return ret;
        }
        Object.keys(val).forEach((key) => {
            if (typeof val[key] === 'undefined' || val[key] == null) {
                val[key] = '';
            }
            if (!key.startsWith(prefix)) {
                ret[prefix + key] = val[key].toString();
                return;
            }
            ret[key] = val[key].toString();
        });
        return ret;
    }
    static parseMeta(val, prefix) {
        let ret = {};
        if (!val) {
            return ret;
        }
        Object.keys(val).forEach((key) => {
            if (key.startsWith(prefix)) {
                ret[key.replace(prefix, '')] = val[key];
                return;
            }
            ret[key] = val[key];
        });
        return ret;
    }
    static getContentType(fileName) {
        return mime_1.getType(fileName) || 'text/plain';
    }
    static getContentMD5(body, isEnableMD5) {
        return kitx_1.default.md5(body, 'hex');
    }
    static encode(val, encodeType) {
        if (!val) {
            return '';
        }
        let strs = val.split('/');
        let str = strs[strs.length - 1];
        switch (encodeType) {
            case 'UrlEncode':
                str = encodeURIComponent(str);
                strs[strs.length - 1] = str;
                return strs.join('/');
            case 'Base64':
                str = Buffer.from(str).toString('base64');
                strs[strs.length - 1] = str;
                return strs.join('/');
        }
    }
    static getUserAgent(val) {
        if (val && val.length) {
            return DEFAULT_AGENT + ' ' + val;
        }
        return DEFAULT_AGENT;
    }
    static getHost(bucketName, regionId, endpoint, hostModel) {
        if (!regionId || !regionId.length) {
            regionId = `cn-hangzhou`;
        }
        if (!endpoint || !endpoint.length) {
            endpoint = `oss-${regionId}.aliyuncs.com`;
        }
        if (!bucketName || !bucketName.length) {
            return endpoint;
        }
        let host = null;
        if (hostModel === 'ip') {
            host = `${endpoint}/${bucketName}`;
        }
        else if (hostModel === 'cname') {
            host = endpoint;
        }
        else {
            host = `${bucketName}.${endpoint}`;
        }
        return host;
    }
    static inject(body, res) {
        let shasum = crypto_1.createHash('md5');
        let crc64 = new crc_1.default();
        body.on('data', function (chunk) {
            shasum.update(chunk);
            crc64.update(chunk);
        });
        body.on('end', function () {
            res['md5'] = shasum.digest('base64');
            res['crc'] = crc64.sum();
        });
        body.pause();
        return body;
    }
    static getSignature(request, bucketName, accessKeyId, accessKeySecret, signatureVersion = 'V2', addtionalHeaders) {
        let signature;
        if (signatureVersion.toUpperCase() === 'V2') {
            let result = signature_1.getSignatureV2(request, bucketName, accessKeySecret, addtionalHeaders);
            if (addtionalHeaders && addtionalHeaders.length > 0) {
                signature = `OSS2 AccessKeyId:${accessKeyId},AdditionalHeaders:${addtionalHeaders.join(';')},Signature:${result.signature}`;
            }
            else {
                signature = `OSS2 AccessKeyId:${accessKeyId},Signature:${result.signature}`;
            }
        }
        else {
            let result = signature_1.getSignatureV1(request, bucketName, accessKeySecret);
            signature = `OSS ${accessKeyId}:${result.signature}`;
        }
        return signature;
    }
    static decode(val, decodeType) {
        if (decodeType == 'Base64Decode') {
            return base64Decode(val);
        }
        else if (decodeType == 'UrlDecode') {
            return decodeURIComponent(val);
        }
        return val;
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map